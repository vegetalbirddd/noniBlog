---
title: 二叉树
date: 2025-11-13
tags:
 - 算法
categories:
 - 算法
---

## 用JS表示二叉树节点

### 创建类
```js
// 创造一个类
class TreeNode {
  constructor(val) {
    this.val = val;       // 节点的值
    this.left = null;     // 左子节点（初始为null，表示无左子树）
    this.right = null;    // 右子节点（初始为null，表示无右子树）
  }
}

const newNode = new TreeNode(5); // 新建一个初始值为5的二叉树节点
newNode.left = new TreeNode(3); // newNode的左右节点也必须是一个二叉树节点
newNode.right = new TreeNode(4);

console.log('noni-treeNode--', newNode);
```

### 构造函数
```js
function TreeNode(val, left, right) {
  this.val = (val===undefined ? 0 : val)
  this.left = (left===undefined ? null : left)
  this.right = (right===undefined ? null : right)
}

const newNode = new TreeNode(5); // 新建一个初始值为5的二叉树节点
newNode.left = new TreeNode(3); // newNode的左右节点也必须是一个二叉树节点
newNode.right = new TreeNode(4);

console.log('noni-treeNode--', newNode);
```

## 遍历二叉树

标记迭代法（通用）：
用栈来存放待处理的节点，如果该节点的左右节点都被处理过，就在这个节点后面塞一个null到栈里，遍历栈的时候，看到null，就知道null的前一个节点已经被处理完成，可以放入res中。前序遍历因为中-左-右的顺序，节点处理完之后可以马上放入res里，所以没有必要用标记法也可以实现迭代


因为栈是后进先出的，所以在遍历每个中间节点的时候，要根据他是什么顺序的遍历，来反向地把节点放入栈里，这样才能保证在拿取栈的节点的顺序是正确的

### 前序遍历
中-左-右
```js
// 递归
var preorderTraversal = function(root, res = []) {
    if(!root) return res;
    res.push(root.val);
    if(root.left) preorderTraversal(root.left, res);
    if(root.right) preorderTraversal(root.right, res);
    return res;
};

// 迭代法
var preorderTraversal = function(root) {
  let res = []
  let stack = []
  if(root) stack.push(root)
  while(stack.length > 0) {
    let node = stack.pop()
    res.push(node.val)
    if(node.right) stack.push(node.right)
    if(node.left) stack.push(node.left)
  }
  return res
}

// 标记位法 统一迭代
var preorderTraversal = function(root) {
    let res = []
    let stack = []
    if (root) stack.push(root)
    while(stack.length) {
      let node = stack.pop()
      if(!node) {
        res.push(stack.pop().val)
        continue
      }
      if(node.right) stack.push(node.right)
      if(node.left) stack.push(node.left)
      stack.push(node)
      stack.push(null)
    }
    return res;
};
```

### 中序遍历
左-中-右
```js
// 递归
var inorderTraversal = function(root,res=[]) {
    if(!root) return [];
    if(root.left) inorderTraversal(root.left,res)
    res.push(root.val)
    if(root.right) inorderTraversal(root.right,res)
    return res
};
// 标记法
var inorderTraversal = function(root) {
    let res=[]
    let stack = []
    if(root) stack.push(root)
    while(stack.length) {
        let node = stack.pop()
        if(!node) {
            res.push(stack.pop().val)
            continue
        }
        if(node.right) stack.push(node.right)
        stack.push(node)
        stack.push(null)
        if(node.left) stack.push(node.left)
    }
    return res
};
```

### 后序遍历
左-右-中
```js
// 递归
var postorderTraversal = function(root, res = []) {
    if(!root) return res;
    if(root.left) postorderTraversal(root.left, res);
    if(root.right) postorderTraversal(root.right, res);
    res.push(root.val);
    return res;
};

// 标记法（处理完的根节点后面加入一个null来标记）
var postorderTraversal = function(root) {
    let res = [];
    let stack = []
    if (root) stack.push(root)
    while(stack.length > 0) {
        let node = stack.pop();
        if(!node) {
            // 遇到标记null，说明下一个节点的左右子树已处理，直接取其值
            res.push(stack.pop().val);
            continue;
        }
        // 首次处理节点：先入栈当前节点，再入栈null作为标记，最后入栈右、左子树
        stack.push(node);      // 最后处理根节点（后序：左→右→根）
        stack.push(null);      // 标记当前节点的左右子树待处理
        if(node.right) stack.push(node.right); // 右子树先入栈（后弹出）
        if(node.left) stack.push(node.left);   // 左子树后入栈（先弹出）
    }
    return res;
};
```

## 层序遍历二叉树
### 题目
- [102.二叉树的层序遍历(opens new window)](https://leetcode.cn/problems/binary-tree-level-order-traversal/)
- [107.二叉树的层次遍历II(opens new window)](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)
- [199.二叉树的右视图(opens new window)](https://leetcode.cn/problems/binary-tree-right-side-view/)
- [637.二叉树的层平均值(opens new window)](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)
- [429.N叉树的层序遍历(opens new window)](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)
- [515.在每个树行中找最大值(opens new window)](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)
- [116.填充每个节点的下一个右侧节点指针(opens new window)](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)
- [117.填充每个节点的下一个右侧节点指针II(opens new window)](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)
- [104.二叉树的最大深度(opens new window)](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)
- [111.二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

### 思路
层序遍历的主要思路就是利用队列queue的先进先出的特点来进行的。
对每一层二叉树进行遍历，在每次遍历里，把该层的节点放入队列中。然后对队列里的节点进行处理，看看节点有没有子节点，有子节点的话就把子节点放在后面。

需要在层遍历里嵌套一层遍历，嵌套的这一层遍历的遍历次数就是上一层的节点数

### 例题1: 二叉树的层序遍历
给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。
![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

示例 1：

输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]



```js
var levelOrder = function(root) {
    let res = []
    let queue = []
    if(root) queue.push(root)
    while(queue.length) {
        let curLen = queue.length
        let arr = []
        for(let i = 0;i<curLen;i++) {
            let node = queue.shift()
            if(node.left) queue.push(node.left)
            if(node.right) queue.push(node.right)
            arr.push(node.val)
        }
        res.push(arr)
    }
    return res;
};
```

## [翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)
其实就是遍历每个节点，然后让每个节点的左右子节点交换一下

```js
var invertTree = function(root) {
    if(!root) return root;
    let temp = root.left
    root.left = root.right
    root.right = temp
    if(root.left) invertTree(root.left)
    if(root.right) invertTree(root.right)
    return root
};
```
---
title: 动态规划学习笔记
date: 2025-08-05
tags:
 - 算法
categories:
 - 算法
---

## 动态规划学习笔记

### 五步曲

- 确定dp数组以及下标的含义
- 确定递归公式
- dp数组如何初始化
- 确定遍历顺序
- 距离推导dp数组

### 例一：[不同路径](https://leetcode.cn/problems/unique-paths/)

题目：一个机器人位于一个 `m x n` 网格的左上角 

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角

问总共有多少条不同的路径？

![img](https://pic.leetcode.cn/1697422740-adxmsI-image.png)

思路：

每到达一个位置，那么在这个位置的上一步，机器人必定是在该位置的上方或左方，到达该位置的总路径就等于“到达上方格子的路径加上到达左方格子的路径”，可以得出递推公式如下：

`dp[i][j] = dp[i-1][j] + dp[i][j-1]`

得到公式后，注意初始化和边界条件。

若网格是单行或单列的，那么路径只会有一条，因此网格数组的首行首列都需要初始化为1

```js
var uniquePaths = function(m, n) {
    const f = new Array(m).fill(0).map(() => new Array(n).fill(0));
    for (let i = 0; i < m; i++) {
        f[i][0] = 1;
    }
    for (let j = 0; j < n; j++) {
        f[0][j] = 1;
    }
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            f[i][j] = f[i - 1][j] + f[i][j - 1];
        }
    }
    return f[m - 1][n - 1];
};
```

### 例二：[不同路径 Ⅱ](https://leetcode.cn/problems/unique-paths-ii/)

题目：给定一个 `m x n` 的整数数组 `grid`。一个机器人初始位于 **左上角**（即 `grid[0][0]`）。机器人尝试移动到 **右下角**（即 `grid[m - 1][n - 1]`）。机器人每次只能向下或者向右移动一步。

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。机器人的移动路径中不能包含 **任何** 有障碍物的方格。

返回机器人能够到达右下角的不同路径数量。

测试用例保证答案小于等于 `2 * 109`。

思路：

我们知道网格内的路径数量递归公式是`dp[i][j] = dp[i-1][j] + dp[i][j-1]`

那么假设有障碍的格子坐标为( i , j )，相当于该`dp[i][j] = 0`，即该位置不通，路径数量为0，那么计算的时候，只有无障碍的格子，才加上路径。

初始化需要注意几个点：

1、首行首列还是初始化为1，但是如果首行首列有障碍，那么从障碍开始后面的格子都初始化为0

2、障碍在起止点的时候没有路径，为0

```js
var uniquePathsWithObstacles = function(obstacleGrid) {
    const m = obstacleGrid.length;
    const n = obstacleGrid[0].length;  
    let dp = new Array(m)
       for(i = 0;i<m;i++) {
        dp[i] = new Array(n).fill(0)
    }
    if(obstacleGrid[0][0] === 1 || obstacleGrid[m-1][n-1] === 1) return 0
    
    for(i = 0;i<m&&obstacleGrid[i][0] ===0;i++) {
        dp[i][0] = 1
    }
    for(i = 0;i<n&&obstacleGrid[0][i] ===0;i++) {
        dp[0][i] = 1
    }
    for(i = 1;i<m;i++) {
       for(j=1;j<n;j++) {
        if(obstacleGrid[i][j] == 0) {
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
        } else {
                dp[i][j] = 0;
            }
       }
    }
    return dp[m-1][n-1]
};
```


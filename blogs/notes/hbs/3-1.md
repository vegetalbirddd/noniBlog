---
title: 语言基础
date: 2024-02-09
---

## 语言基础

### 3.1  语法

#### 3.1  基础

1、一切都区分大小写

2、标识符第一个字符必须为一个字母、下划线（_）或美元符号（$）；其他字符可以是字母、下划线、美元符号或数字。关键字、保留字、true、false和null不能作为标识符。

3、单行注释和块注释

```js
// 单行注释
/* 块注释
*/
```

4、严格模式：ECMAScript 3的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。

启用：在脚本开头加上"use strict"，也可以放到函数体开头，单独指定一个函数在严格模式下执行

5、语句末尾分号不必须

### 3.2  关键字与保留字

ECMA-262第6版(es6)规定的所有关键字

```
break       do          in            typeof
case        else        instanceof    var
catch       export      new           void
class       extends     return        while
const       finally     super         with
continue    for         switch        yield
debugger    function    this
default     if          throw
delete      import      try
```

ECMA-262第6版为将来保留的所有词汇

```
始终保留: 
enum
 
严格模式下保留: 
implements  package     public
interface   protected   static
let         private
 
模块代码中保留: 
await
```

### 3.3  变量

ECMAScript 变量是松散类型的，意思是变量可以用于保存任何类型的数据。每个变量只不过是一个用于保存任意值的命名占位符。有3个关键字可以声明变量：var、const、let。

##### 3.3.1  var关键字

**声明作用域：**使用 var 操作符定义的变量会成为包含它的函数的局部变量。在函数内定义变量时省略var操作符，可以创建一个全局变量。使用var在全局作用域中声明的变量会成为window对象的属性。

```js
function test() { 
	message = "hi";     // 全局变量 
} 
test(); 
console.log(message); // "hi" 
```

> 在严格模式下，如果像这样给未声明的变量赋值，则会导致抛出ReferenceError。

**声明提升：**调用某变量的语句在声明该变量之前不会报错。关键字声明的变量会自动提升到函数作用域顶部。所谓的“提升”（hoist），就是把所有变量声明都拉到函数作用域的顶部。可以反复多次使用var声明同一个变量。

```js
function foo() {  
  console.log(age); 
  var age = 26; 
} 
foo();  // undefined 
```

等价于：

```js
function foo() { 
var age; 
  console.log(age); 
  age = 26; 
} 
foo();  // undefined 
```

##### 3.3.2  let声明

let声明的范围是块作用域，var声明的范围是函数作用域。块作用域是函数作用域的**子集**，因此适用于var的作用域限制同样也适用于let。let不允许**同一个块作用域**中出现**冗余声明**（多次用let声明同一个变量）。

```js
//var
if (true) { 
  var name = 'Matt'; 
  console.log(name); // Matt 
} 
console.log(name);   // Matt 

//let
if (true) { 
  let age = 26; 
  console.log(age);   // 26 
} 
console.log(age);     // ReferenceError: age 没有定义 
```

**暂时性死区：**let声明的变量不会在作用域中被提升。在let声明之前的执行瞬间被称为“暂时性死区”（temporal dead zone），在此阶段引用任何后面才用let声明的变量都会抛出ReferenceError。

**全局声明：**与var关键字不同，使用let在全局作用域中声明的变量不会成为window对象的属性，但是变量会在页面的生命周期内存续。

**条件声明：**不能使用let进行条件式声明。

**for 循环中的let 声明：**在for循环中使用let声明迭代变量时，JavaScript引擎在后台会为每个迭代循环声明一个新的迭代变量。

```js
for (var i = 0; i < 5; ++i) { 
    setTimeout(() => console.log(i), 0) 
} 
// 实际上会输出5、5、5、5、5 
```

```js
for (let i = 0; i < 5; ++i) { 
    setTimeout(() => console.log(i), 0) 
} 
// 会输出0、1、2、3、4 
```

> 在退出循环时，迭代变量保存的是导致循环退出的值：5。在之后执行超时逻辑时，所有的i都是同一个变量，因而输出的都是同一个最终值。 

##### 3.3.3  const声明

const与let类似，但是用const声明变量时必须同时**初始化变量**，且尝试修改const声明的变量会导致运行时错误。 

const声明的限制**只适用于它指向的变量的引用**。如果const变量引用的是一个对象， 那么修改这个对象**内部的属性**并不违反const的限制。

```js
const person = {}; 
person.name = 'Matt';  // ok 
```

##### 3.3.4 声明风格及最佳实践

**不使用var：**限制自己只使用let 和const 有助于提升代码质量，因为变量有了明确的作用域、声明位置，以及不变的值。 

**const 优先，let 次之：**使用 const 声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。

### 3.4  数据类型

基本数据类型（原始类型）：Undefined、Null、Boolean、Number、 String 、Symbol和BigInt（ES2020）

引用类型：Object
import{_ as e,o as a,c as d,b as o}from"./app-6b6c2416.js";const t={},i=o('<h1 id="事件实现原理" tabindex="-1"><a class="header-anchor" href="#事件实现原理" aria-hidden="true">#</a> 事件实现原理</h1><h2 id="事件机制组成" tabindex="-1"><a class="header-anchor" href="#事件机制组成" aria-hidden="true">#</a> 事件机制组成</h2><ul><li>事件源（发布者）：事件的发送者，比如标签button</li><li>事件（订阅中心）：事件源发出的一种信息或状态，比如说click事件</li><li>事件监听者（订阅者）：对事件做出反应的对象。一般是一个函数，当事件发送时调用此函数</li></ul><p>事件实现通过发布订阅模式来实现，事件源先注册事件，当触发事件时，遍历监听者列表，若绑定了对应事件，则执行此事件。</p><h2 id="web端dom处理事件" tabindex="-1"><a class="header-anchor" href="#web端dom处理事件" aria-hidden="true">#</a> web端DOM处理事件</h2><p>DOM0级事件：DOM0级处理事件就是将一个函数赋值给一个事件处理属性。dom节点通过onclick绑定事件，通过dom.onclick = null来解绑事件；</p><p>DOM2级事件：在DOM0级处理事件基础之上添加一些处理程序。</p><ul><li>dom节点通过**addEventListener()<strong>方法注册事件，通过</strong>removeEventListener()**来注销事件；</li><li>可以同时绑定多个事件处理函数。</li></ul><p>DOM3级事件：<strong>CSS中</strong>设置ui事件，比如：hover事件，焦点事件(input框)等；</p><blockquote><p>三类补充</p><p>UI事件，当用户与页面上的元素交互时触发，如：<code>load</code>、<code>scroll</code></p><p>焦点事件，当元素获得或失去焦点时触发，如：<code>blur</code>、<code>focus</code></p><p>鼠标事件，当用户通过鼠标在页面执行操作时触发如：<code>dbclick</code>、<code>mouseup</code></p><p>滚轮事件，当使用鼠标滚轮或类似设备时触发，如：<code>mousewheel</code></p><p>文本事件，当在文档中输入文本时触发，如：<code>textInput</code></p><p>键盘事件，当用户通过键盘在页面上执行操作时触发，如：<code>keydown</code>、<code>keypress</code></p><p>合成事件，当为IME（输入法编辑器）输入字符时触发，如：<code>compositionstart</code></p><p>变动事件，当底层DOM结构发生变化时触发，如：<code>DOMsubtreeModified</code></p></blockquote><h2 id="dom事件流存在的三个阶段" tabindex="-1"><a class="header-anchor" href="#dom事件流存在的三个阶段" aria-hidden="true">#</a> <strong>DOM事件流存在的三个阶段</strong>：</h2><ul><li>事件捕获阶段</li><li>处于目标阶段</li><li>事件冒泡阶段</li></ul><p>DOM标准事件流的触发的先后顺序为：先捕获再冒泡，即当触发dom事件时，会先进行事件捕获，捕获到事件源之后通过事件传播进行事件冒泡。</p><blockquote><p>addEventListener()方法的第三个参数默认为false，触发事件冒泡</p><p>改为true，触发事件捕获</p></blockquote><h3 id="target-和-currenttarget" tabindex="-1"><a class="header-anchor" href="#target-和-currenttarget" aria-hidden="true">#</a> target 和 currentTarget</h3><p>target是触发事件的某个具体的对象，只会出现在事件机制的目标阶段，即&quot;谁触发了事件，谁就是target&quot;。 currentTarget是绑定了当前事件类型的对象，有可能是目标节点的祖先节点。</p><h3 id="性能优化" tabindex="-1"><a class="header-anchor" href="#性能优化" aria-hidden="true">#</a> 性能优化</h3><h4 id="阻止冒泡" tabindex="-1"><a class="header-anchor" href="#阻止冒泡" aria-hidden="true">#</a> 阻止冒泡</h4><ul><li><p><code>event.stopPropagation() </code>阻止事件进一步向上冒泡</p></li><li><p><code>event.preventDefault()</code>阻止默认事件的方法</p></li><li><p>return false</p></li></ul><h4 id="避免频繁触发" tabindex="-1"><a class="header-anchor" href="#避免频繁触发" aria-hidden="true">#</a> 避免频繁触发</h4><p>防抖节流</p><ul><li>节流：在一定时间内只执行一次事件处理函数，例如使用<code>lodash</code>库的<code>_.throttle</code>方法。</li><li>防抖：在事件连续触发结束后，延迟指定时间后执行事件处理函数，例如使用<code>lodash</code>库的<code>_.debounce</code>方法。</li></ul><h4 id="事件绑定优化" tabindex="-1"><a class="header-anchor" href="#事件绑定优化" aria-hidden="true">#</a> 事件绑定优化</h4><ul><li>尽量使用事件委托，避免为大量子元素重复绑定事件处理函数。</li><li>使用事件代理库如<code>Delegate</code>或<code>Zepto</code>，优化事件绑定和处理性能。</li></ul><h4 id="及时移除事件监听器" tabindex="-1"><a class="header-anchor" href="#及时移除事件监听器" aria-hidden="true">#</a> 及时移除事件监听器</h4><ul><li>不及时移除可能产生内存泄漏或触发不必要的事件处理</li><li>使用<code>element.removeEventListener(event, callback)</code>来移除</li></ul><h4 id="使用try-catch捕获事件处理函数错误" tabindex="-1"><a class="header-anchor" href="#使用try-catch捕获事件处理函数错误" aria-hidden="true">#</a> 使用try-catch捕获事件处理函数错误</h4><ul><li>使用<code>try-catch</code>语句块捕获事件处理函数中的错误，避免错误导致整个页面崩溃</li><li>错误处理应细化到单个事件处理函数，以方便定位和修复问题。</li></ul><h2 id="参考文献" tabindex="-1"><a class="header-anchor" href="#参考文献" aria-hidden="true">#</a> 参考文献</h2><p>https://www.cnblogs.com/snsart/p/10881168.html</p>',30),r=[i];function c(l,h){return a(),d("div",null,r)}const s=e(t,[["render",c],["__file","shijianshixianyuanli.html.vue"]]);export{s as default};

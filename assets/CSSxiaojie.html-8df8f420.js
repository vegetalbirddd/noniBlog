import{_ as e,o as n,c as a,b as s}from"./app-c1d09215.js";const i={},p=s(`<h2 id="css" tabindex="-1"><a class="header-anchor" href="#css" aria-hidden="true">#</a> CSS</h2><h2 id="一、css基础" tabindex="-1"><a class="header-anchor" href="#一、css基础" aria-hidden="true">#</a> 一、CSS基础</h2><h3 id="css的选择器和优先级" tabindex="-1"><a class="header-anchor" href="#css的选择器和优先级" aria-hidden="true">#</a> CSS的选择器和优先级？</h3><p>CSS的选择器里，id选择器的优先级最高，优先级权重为100；其次是类选择器、伪类选择器、属性选择器，优先级权重是10；再来是标签选择器、伪元素选择器，权重为1；最后是通配符选择器、子选择器，权重为0。</p><p>一个样式是否生效，可以由该样式的选择器优先级权重相加对比，权重越高的就越优先展示；如果样式的优先级权重相同，那么放在后面的样式会覆盖放在前面的样式。</p><p>除此之外，内联样式展示的优先顺序大于选择器内的样式，而如果选择器内的样式有<code>!important</code>，那么则这个样式的优先级最高；</p><p>优先级顺序是：<code>!important</code> &gt; 内联样式 &gt; 内部样式 &gt; 外部样式</p><blockquote><p>小点：权重不可进位，11个类选择器的优先级低于1个id选择器</p></blockquote><h3 id="伪元素和伪类元素是什么-区别" tabindex="-1"><a class="header-anchor" href="#伪元素和伪类元素是什么-区别" aria-hidden="true">#</a> 伪元素和伪类元素是什么？区别？</h3><p>伪元素在某个元素的前后加上一个可以显示的元素，但这个元素并不会被渲染到DOM树上；</p><p>伪类元素可以给某个特定状态下的元素增加样式，比如对某个元素:hover，就可以在hover该元素的时候展示指定的样式</p><p>区别：伪类是对元素的某个状态增加样式，伪元素表现会像往标记文本加入新的标签一样</p><p>小点：<code>::first-line</code>伪元素选择器只会选中第一行</p><blockquote><p>CSS3 之后，为了区别伪类选择器和伪元素，在伪元素前加两个 ::</p><p>::before 和 ::after 相当于 在 element 和 content 之间多了两个图层，改善了 CSS 布局能力的不足,且 ::before 和 ::after 属性中必须有 &#39;content:&#39; 属性，content 属性可以为空 &#39;&#39;</p></blockquote><h3 id="display相关" tabindex="-1"><a class="header-anchor" href="#display相关" aria-hidden="true">#</a> display相关</h3><p><strong>none</strong>：元素不显示，从文档流移除</p><p><strong>block</strong>：块元素，独占一行，可以设置宽高</p><p><strong>inline</strong>：行内元素，不换行，不可设置宽高，不可设置垂直margin</p><p><strong>inline-block</strong>：行内块元素，不换行，可以设置宽高</p><h3 id="隐藏元素方法" tabindex="-1"><a class="header-anchor" href="#隐藏元素方法" aria-hidden="true">#</a> 隐藏元素方法</h3><p><code>display: none</code>: 元素从文档流移除，不再占据空间，不被加入到render tree，元素不响应绑定事件</p><p><code>visibility: hidden</code>: 元素仍占据空间但是看不到，加入了render tree，元素不响应绑定事件</p><p><code>opacity: 0</code>: 透明度调为0</p><p><code>z-index:负数</code>: 使元素被覆盖</p><p><code>transform:scale(0,0)</code>: 元素缩放为0</p><blockquote><p>scale[skeɪl]</p><p>display：none和visibility：hidden 的区别：1、文档流，空间 2、渲染树 3、display不继承，visibility继承 4、display重排，visibility重绘</p></blockquote><h3 id="盒模型" tabindex="-1"><a class="header-anchor" href="#盒模型" aria-hidden="true">#</a> 盒模型</h3><p>组成：由content、padding、border、margin组成</p><h4 id="种类" tabindex="-1"><a class="header-anchor" href="#种类" aria-hidden="true">#</a> 种类</h4><p><code>box-sizing: content-box</code>（标准盒）：宽高只由内容决定</p><p><code>box-sizing: border-box</code>（IE盒）：宽高由内容、border、padding决定</p><h3 id="可继承与不可继承属性" tabindex="-1"><a class="header-anchor" href="#可继承与不可继承属性" aria-hidden="true">#</a> 可继承与不可继承属性</h3><h4 id="可继承" tabindex="-1"><a class="header-anchor" href="#可继承" aria-hidden="true">#</a> 可继承</h4><p>字体：字体大小、粗细</p><p>文本：line-height、color、text-align</p><p>可见性：visibility</p><p>光标：cursor</p><h4 id="不可继承" tabindex="-1"><a class="header-anchor" href="#不可继承" aria-hidden="true">#</a> 不可继承</h4><p>盒模型属性：宽高、行内外距、边框</p><p>定位属性：position、top...、float</p><p>背景属性：背景颜色、图片、平铺方式</p><h3 id="link、-import区别" tabindex="-1"><a class="header-anchor" href="#link、-import区别" aria-hidden="true">#</a> link、@import区别</h3><p>**从属关系：**link是html标签，用来规定文档和外部资源的关系，他不止可以用来链接样式表，也可以用来链接图标；@import只能拿来引入样式</p><p>**加载顺序：**link是标签，所以和html同时加载；而import会等当前 CSS 文件加载并解析完成后再加载</p><p>**兼容性：**link没有兼容性的问题，但是import是CSS2.1后引入的，所以低版本浏览器可能不支持</p><p>**DOM：**可以对link进行一些DOM操作，比如更换链接属性等；import则不行</p><p>**显示：**import被引入后，会被放置于样式表顶部，所以如果同个选择器的同个样式，link的样式会覆盖import的样式</p><h3 id="css-sprites-的理解" tabindex="-1"><a class="header-anchor" href="#css-sprites-的理解" aria-hidden="true">#</a> CSS Sprites 的理解</h3><p>把小图组合成一张大图，在项目中利用<code>background-image</code>,<code>background-repeat</code> ,<code>background-position</code>来展示需要的图片。</p><p>**优点：**1、只需要一张图，减少请求次数；2、一张图的内存占用比起多张图会更小</p><p>**缺点：**1、开发的时候需要测量图片的精确位置，比较麻烦；2、维护起来比较难，改动图片的时候可能需要改动CSS</p><h3 id="css预处理器-后处理器" tabindex="-1"><a class="header-anchor" href="#css预处理器-后处理器" aria-hidden="true">#</a> CSS预处理器/后处理器</h3><p>两者都是对CSS的工程化实践</p><p>**预处理器：**CSS 预处理器（如 Sass、Less、Stylus），类CSS，通过引入嵌套规则、混入（Mixin）、函数、变量等编程式特性，弥补了原生 CSS 在代码组织、复用和逻辑处理上的不足，让样式开发更高效、更具可维护性，同时能更好地支撑大型项目的样式管理。</p><p>**后处理器：**对写好的CSS做一些处理，最常用的是给属性加浏览器私有前缀，实现浏览器在样式上的兼容问题。</p><p>CSS 预处理器（如 Sass、Less、Stylus）通过引入嵌套规则、混入（Mixin）、函数、变量等编程式特性，弥补了原生 CSS 在代码组织、复用和逻辑处理上的不足，让样式开发更高效、更具可维护性，同时能更好地支撑大型项目的样式管理。</p><p>**区别：**预处理器的工作流程是 预处理器语法代码-&gt;编译-&gt;原生CSS（编写增强）</p><p>后处理器 原生CSS-&gt;后处理-&gt;优化后的CSS（输出优化）</p><h3 id="line-height" tabindex="-1"><a class="header-anchor" href="#line-height" aria-hidden="true">#</a> line-height</h3><ul><li><p>单行文本的高度，是上一行基线到下一行的基线</p></li><li><p>当没有高度的时候，元素的高度由行高来撑起</p></li><li><p>如果赋值纯数字，那么就是数字*子元素的<code>font-size</code></p></li></ul><h3 id="媒体查询理解" tabindex="-1"><a class="header-anchor" href="#媒体查询理解" aria-hidden="true">#</a> 媒体查询理解</h3><p>针对不同的屏幕尺寸来设定不同的样式</p><h3 id="z-index" tabindex="-1"><a class="header-anchor" href="#z-index" aria-hidden="true">#</a> z-index</h3><p>可以在一定程度上决定元素在z轴上的位置，只在有定位属性的元素上生效，元素在z轴上层叠顺序还由层叠上下文、层叠规则来决定。</p><p>**层叠上下文：**当给元素定位属性的时候，可以给元素建立一个层叠上下文，层叠上下文可以限制内部元素，不被外部元素影响</p><p><strong>层叠等级：</strong><code>background</code> <code>border</code> &lt; z-index负数 &lt; block &lt; float &lt; <code>inline</code> <code>inline-block</code> &lt; z-index: 0 /auto &lt; z-index正数</p><p>当元素在不同层叠上下文的时候，先看层叠上下文的优先顺序，在同一个层叠上下文中的元素再看层叠等级来确定层叠顺序</p><h3 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h3><h2 id="二、页面布局" tabindex="-1"><a class="header-anchor" href="#二、页面布局" aria-hidden="true">#</a> 二、页面布局</h2><h3 id="布局单位" tabindex="-1"><a class="header-anchor" href="#布局单位" aria-hidden="true">#</a> 布局单位</h3><p>**px：**CSS像素，是相对固定的单位（受屏幕分辨率和缩放影响）</p><p><strong>em：<strong>相对单位，相对于</strong>当前对象内</strong>行内文本的font-size的倍数</p><p>**rem：**相对于根元素的font-size的倍数</p><p>**vh：**相对于视图高度</p><p>**vw：**相对于视图宽度</p><div class="language-css line-numbers-mode" data-ext="css"><pre class="language-css"><code><span class="token selector">.parent</span> <span class="token punctuation">{</span>
  <span class="token property">font-size</span><span class="token punctuation">:</span> 16px<span class="token punctuation">;</span> <span class="token comment">/* 父元素字体大小 */</span>
<span class="token punctuation">}</span>
<span class="token selector">.child</span> <span class="token punctuation">{</span>
  <span class="token property">font-size</span><span class="token punctuation">:</span> 1.5em<span class="token punctuation">;</span> <span class="token comment">/* 1.5 × 16px = 24px */</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 10em<span class="token punctuation">;</span> <span class="token comment">/* 10 × 24px（当前元素font-size）= 240px */</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><pre class="language-css"><code><span class="token selector">html</span> <span class="token punctuation">{</span>
  <span class="token property">font-size</span><span class="token punctuation">:</span> 16px<span class="token punctuation">;</span> <span class="token comment">/* 根元素字体大小（默认通常为16px） */</span>
<span class="token punctuation">}</span>
<span class="token selector">.box</span> <span class="token punctuation">{</span>
  <span class="token property">font-size</span><span class="token punctuation">:</span> 1.2rem<span class="token punctuation">;</span> <span class="token comment">/* 1.2 × 16px = 19.2px */</span>
  <span class="token property">margin</span><span class="token punctuation">:</span> 2rem<span class="token punctuation">;</span> <span class="token comment">/* 2 × 16px = 32px */</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,77),t=[p];function o(d,c){return n(),a("div",null,t)}const l=e(i,[["render",o],["__file","CSSxiaojie.html.vue"]]);export{l as default};
